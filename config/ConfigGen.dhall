let data = ./data.dhall

let Prelude = ./Prelude.dhall

let list =
      \(fieldType : data.EnumType) ->
        Prelude.Text.concatMap
          { index : Natural, value : data.Enum }
          ( \(enum : { index : Natural, value : data.Enum }) ->
                  "\\\"${data.showEnumPretty enum.value}\\\""
              ++  ( if        Prelude.Natural.greaterThan
                                ( Prelude.List.length
                                    data.Enum
                                    fieldType.constructors
                                )
                                2
                          &&  Prelude.Natural.lessThan
                                (enum.index + 1)
                                ( Prelude.List.length
                                    data.Enum
                                    fieldType.constructors
                                )
                    then  ","
                    else  ""
                  )
              ++  ( if    Prelude.Natural.lessThan
                            (enum.index + 1)
                            ( Prelude.List.length
                                data.Enum
                                fieldType.constructors
                            )
                    then  " "
                    else  ""
                  )
              ++  ( if    Prelude.Natural.equal
                            (enum.index + 2)
                            ( Prelude.List.length
                                data.Enum
                                fieldType.constructors
                            )
                    then  "or "
                    else  ""
                  )
          )
          (Prelude.List.indexed data.Enum fieldType.constructors)

let parsePrinterOptTypeEnum =
      \(x : data.EnumType) ->
        ''
        \s ->
            case s of
        ${Prelude.Text.concatMap
            data.Enum
            ( \(enum : data.Enum) ->
                ''
                      "${data.showEnumPretty enum}" -> Right ${data.showEnum
                                                                 enum}
                ''
            )
            x.constructors}      _ ->
                Left . unlines $
                  [ "unknown value: " <> show s
                  , "Valid values are: ${list x}"
                  ]''

let parsePrinterOptType =
      \(fieldType : data.FieldType) ->
        merge
          { Enum = \(x : data.EnumType) -> parsePrinterOptTypeEnum x
          , ADT = \(x : data.ADT) -> x.parsePrinterOptType
          }
          fieldType

let instance1 =
      \(typeName : Text) ->
      \(parsePrinterOptType : Text) ->
        ''
        instance PrinterOptsFieldType ${typeName} where
          parsePrinterOptType = ${parsePrinterOptType}''

let instance =
      \(fieldType : data.FieldType) ->
        instance1 (data.typeName fieldType) (parsePrinterOptType fieldType)

in  ''
    {- FOURMOLU_DISABLE -}
    {- ***** DO NOT EDIT: This module is autogenerated ***** -}

    {-# LANGUAGE DeriveGeneric #-}
    {-# LANGUAGE OverloadedStrings #-}
    {-# LANGUAGE RankNTypes #-}

    module Ormolu.Config.Gen
      ( PrinterOpts (..)
    ${Prelude.Text.concatMapSep
        "\n"
        data.FieldType
        (\(fieldType : data.FieldType) -> "  , ${data.typeName fieldType} (..)")
        data.fieldTypes}
      , emptyPrinterOpts
      , defaultPrinterOpts
      , fillMissingPrinterOpts
      , parsePrinterOptsCLI
      , parsePrinterOptsJSON
      , parsePrinterOptType
      )
    where

    import qualified Data.Aeson as Aeson
    import qualified Data.Aeson.Types as Aeson
    import Data.Functor.Identity (Identity)
    import qualified Data.Text as Text
    import GHC.Generics (Generic)
    import Text.Read (readEither)

    -- | Options controlling formatting output.
    data PrinterOpts f =
      PrinterOpts
    ${Prelude.Text.concatMap
        { index : Natural, value : data.Option }
        ( \(option : { index : Natural, value : data.Option }) ->
            let lead = if Prelude.Natural.isZero option.index then "{" else ","

            in  ''
                    ${lead} -- | ${option.value.description}
                      ${option.value.fieldName} :: f ${data.showType
                                                         option.value.type}
                ''
        )
        (Prelude.List.indexed data.Option data.options)}    }
      deriving (Generic)

    emptyPrinterOpts :: PrinterOpts Maybe
    emptyPrinterOpts =
      PrinterOpts
    ${Prelude.Text.concatMap
        { index : Natural, value : data.Option }
        ( \(option : { index : Natural, value : data.Option }) ->
            let lead = if Prelude.Natural.isZero option.index then "{" else ","

            in  ''
                    ${lead} ${option.value.fieldName} = Nothing
                ''
        )
        (Prelude.List.indexed data.Option data.options)}    }

    defaultPrinterOpts :: PrinterOpts Identity
    defaultPrinterOpts =
      PrinterOpts
    ${Prelude.Text.concatMap
        { index : Natural, value : data.Option }
        ( \(option : { index : Natural, value : data.Option }) ->
            let lead = if Prelude.Natural.isZero option.index then "{" else ","

            in  ''
                    ${lead} ${option.value.fieldName} = pure ${data.showValue
                                                                 option.value.default}
                ''
        )
        (Prelude.List.indexed data.Option data.options)}    }

    -- | Fill the field values that are 'Nothing' in the first argument
    -- with the values of the corresponding fields of the second argument.
    fillMissingPrinterOpts ::
      forall f.
      Applicative f =>
      PrinterOpts Maybe ->
      PrinterOpts f ->
      PrinterOpts f
    fillMissingPrinterOpts p1 p2 =
      PrinterOpts
    ${Prelude.Text.concatMap
        { index : Natural, value : data.Option }
        ( \(option : { index : Natural, value : data.Option }) ->
            let lead = if Prelude.Natural.isZero option.index then "{" else ","

            in  ''
                    ${lead} ${option.value.fieldName} = maybe (${option.value.fieldName} p2) pure (${option.value.fieldName} p1)
                ''
        )
        (Prelude.List.indexed data.Option data.options)}    }

    parsePrinterOptsCLI ::
      Applicative f =>
      (forall a. PrinterOptsFieldType a => String -> String -> String -> f (Maybe a)) ->
      f (PrinterOpts Maybe)
    parsePrinterOptsCLI f =
      pure PrinterOpts
    ${Prelude.Text.concatMap
        { index : Natural, value : data.Option }
        ( \(option : { index : Natural, value : data.Option }) ->
            let choices =
                  merge
                    { Bool = ""
                    , Natural = ""
                    , Text = ""
                    , Enum = \(ft : data.EnumType) -> "(choices: ${list ft}) "
                    , ADT = \(ft : data.ADT) -> ""
                    }
                    option.value.type

            let default =
                  "${option.value.description} ${choices}(default: ${data.showValuePretty
                                                                       option.value.default})"

            in  ''
                    <*> f
                      "${option.value.name}"
                      "${merge
                           { Enum = \(x : data.EnumType) -> default
                           , Bool = default
                           , Natural = default
                           , Text = default
                           , ADT = \(x : data.ADT) -> x.cli
                           }
                           option.value.type}"
                      "${data.showPlaceholder option.value.type}"
                ''
        )
        (Prelude.List.indexed data.Option data.options)}
    parsePrinterOptsJSON ::
      Applicative f =>
      (forall a. PrinterOptsFieldType a => String -> f (Maybe a)) ->
      f (PrinterOpts Maybe)
    parsePrinterOptsJSON f =
      pure PrinterOpts
    ${Prelude.Text.concatMap
        { index : Natural, value : data.Option }
        ( \(option : { index : Natural, value : data.Option }) ->
            ''
                <*> f "${option.value.name}"
            ''
        )
        (Prelude.List.indexed data.Option data.options)}
    {---------- PrinterOpts field types ----------}

    class Aeson.FromJSON a => PrinterOptsFieldType a where
      parsePrinterOptType :: String -> Either String a

    instance PrinterOptsFieldType Int where
      parsePrinterOptType = readEither

    ${instance (data.FieldType.Enum data.Boolean)}


    ${Prelude.Text.concatMapSep
        "\n"
        data.FieldType
        ( \(fieldType : data.FieldType) ->
            ''
            data ${data.typeName fieldType}
            ${Prelude.Text.concatMap
                { index : Natural, value : Text }
                ( \(enum : { index : Natural, value : Text }) ->
                    let lead =
                          if Prelude.Natural.isZero enum.index then "=" else "|"

                    in  ''
                          ${lead} ${enum.value}
                        ''
                )
                ( Prelude.List.indexed
                    Text
                    ( merge
                        { Enum =
                            \(x : data.EnumType) ->
                              Prelude.List.map
                                data.Enum
                                Text
                                data.showEnum
                                x.constructors
                        , ADT = \(x : data.ADT) -> x.constructors
                        }
                        fieldType
                    )
                )}  ${merge
                        { Enum =
                            \(x : data.EnumType) ->
                              "deriving (Eq, Show, Enum, Bounded)"
                        , ADT = \(x : data.ADT) -> "deriving (Eq, Show)"
                        }
                        fieldType}
            ''
        )
        data.fieldTypes}
    ${Prelude.Text.concatMapSep
        "\n"
        data.FieldType
        ( \(fieldType : data.FieldType) ->
            ''
            ${merge
                { Enum =
                    \(x : data.EnumType) ->
                      ''
                      instance Aeson.FromJSON ${data.typeName fieldType} where
                        parseJSON =
                          Aeson.withText "${data.typeName fieldType}" $ \s ->
                            either Aeson.parseFail pure $
                              parsePrinterOptType (Text.unpack s)''
                , ADT =
                    \(x : data.ADT) ->
                          "instance Aeson.FromJSON ${data.typeName
                                                       fieldType} where"
                      ++  ''

                          ${"  "}parseJSON = ${x.parseJSON}''
                }
                fieldType}

            ${instance fieldType}
            ''
        )
        data.fieldTypes}''
