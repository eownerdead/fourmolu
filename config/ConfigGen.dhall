let data = ./data.dhall

let Prelude =
      https://prelude.dhall-lang.org/v17.0.0/package.dhall
        sha256:10db3c919c25e9046833df897a8ffe2701dc390fa0893d958c3430524be5a43e

let list =
      \(fieldType : data.EnumType) ->
        Prelude.Text.concatMap
          { index : Natural, value : data.Enum }
          ( \(enum : { index : Natural, value : data.Enum }) ->
                  "\\\"${data.showEnumPretty enum.value}\\\""
              ++  ( if        Prelude.Natural.greaterThan
                                ( Prelude.List.length
                                    data.Enum
                                    fieldType.constructors
                                )
                                2
                          &&  Prelude.Natural.lessThan
                                (enum.index + 1)
                                ( Prelude.List.length
                                    data.Enum
                                    fieldType.constructors
                                )
                    then  ","
                    else  ""
                  )
              ++  ( if    Prelude.Natural.lessThan
                            (enum.index + 1)
                            ( Prelude.List.length
                                data.Enum
                                fieldType.constructors
                            )
                    then  " "
                    else  ""
                  )
              ++  ( if    Prelude.Natural.equal
                            (enum.index + 2)
                            ( Prelude.List.length
                                data.Enum
                                fieldType.constructors
                            )
                    then  "or "
                    else  ""
                  )
          )
          (Prelude.List.indexed data.Enum fieldType.constructors)

let q = 1

in  ''
    {- FOURMOLU_DISABLE -}
    {- ***** DO NOT EDIT: This module is autogenerated ***** -}

    {-# LANGUAGE DeriveGeneric #-}
    {-# LANGUAGE OverloadedStrings #-}
    {-# LANGUAGE RankNTypes #-}

    module Ormolu.Config.Gen
      ( PrinterOpts (..)
    ${Prelude.Text.concatMapSep
        "\n"
        data.FieldType
        (\(fieldType : data.FieldType) -> "  , ${data.typeName fieldType} (..)")
        data.fieldTypes}
      , emptyPrinterOpts
      , defaultPrinterOpts
      , fillMissingPrinterOpts
      , parsePrinterOptsCLI
      , parsePrinterOptsJSON
      , parsePrinterOptType
      )
    where

    import qualified Data.Aeson as Aeson
    import qualified Data.Aeson.Types as Aeson
    import Data.Functor.Identity (Identity)
    import qualified Data.Text as Text
    import GHC.Generics (Generic)
    import Text.Read (readEither)

    -- | Options controlling formatting output.
    data PrinterOpts f =
      PrinterOpts
    ${Prelude.Text.concatMap
        { index : Natural, value : data.Option }
        ( \(option : { index : Natural, value : data.Option }) ->
            let lead = if Prelude.Natural.isZero option.index then "{" else ","

            in  ''
                    ${lead} -- | ${option.value.description}
                      ${option.value.fieldName} :: f ${data.showType
                                                         option.value.type_}
                ''
        )
        (Prelude.List.indexed data.Option data.options)}    }
      deriving (Generic)

    emptyPrinterOpts :: PrinterOpts Maybe
    emptyPrinterOpts =
      PrinterOpts
    ${Prelude.Text.concatMap
        { index : Natural, value : data.Option }
        ( \(option : { index : Natural, value : data.Option }) ->
            let lead = if Prelude.Natural.isZero option.index then "{" else ","

            in  ''
                    ${lead} ${option.value.fieldName} = Nothing
                ''
        )
        (Prelude.List.indexed data.Option data.options)}    }

    defaultPrinterOpts :: PrinterOpts Identity
    defaultPrinterOpts =
      PrinterOpts
    ${Prelude.Text.concatMap
        { index : Natural, value : data.Option }
        ( \(option : { index : Natural, value : data.Option }) ->
            let lead = if Prelude.Natural.isZero option.index then "{" else ","

            in  ''
                    ${lead} ${option.value.fieldName} = pure ${data.showValue
                                                                 option.value.default_}
                ''
        )
        (Prelude.List.indexed data.Option data.options)}    }

    -- | Fill the field values that are 'Nothing' in the first argument
    -- with the values of the corresponding fields of the second argument.
    fillMissingPrinterOpts ::
      forall f.
      Applicative f =>
      PrinterOpts Maybe ->
      PrinterOpts f ->
      PrinterOpts f
    fillMissingPrinterOpts p1 p2 =
      PrinterOpts
    ${Prelude.Text.concatMap
        { index : Natural, value : data.Option }
        ( \(option : { index : Natural, value : data.Option }) ->
            let lead = if Prelude.Natural.isZero option.index then "{" else ","

            in  ''
                    ${lead} ${option.value.fieldName} = maybe (${option.value.fieldName} p2) pure (${option.value.fieldName} p1)
                ''
        )
        (Prelude.List.indexed data.Option data.options)}    }

    parsePrinterOptsCLI ::
      Applicative f =>
      (forall a. PrinterOptsFieldType a => String -> String -> String -> f (Maybe a)) ->
      f (PrinterOpts Maybe)
    parsePrinterOptsCLI f =
      pure PrinterOpts
    ${Prelude.Text.concatMap
        { index : Natural, value : data.Option }
        ( \(option : { index : Natural, value : data.Option }) ->
            let lead = if Prelude.Natural.isZero option.index then "{" else ","

            in  let choices =
                      merge
                        { Bool = ""
                        , Natural = ""
                        , Text = ""
                        , Enum =
                            \(ft : data.EnumType) -> "(choices: ${list ft}) "
                        , ADT = \(ft : data.ADT) -> ""
                        }
                        option.value.type_

                let default =
                      "${option.value.description} ${choices}(default: ${data.showValuePretty
                                                                           option.value.default_})"

                in  ''
                        <*> f
                          "${option.value.name}"
                          "${merge
                               { Enum = \(x : data.EnumType) -> default
                               , Bool = default
                               , Natural = default
                               , Text = default
                               , ADT = \(x : data.ADT) -> x.cli
                               }
                               option.value.type_}"
                          "${data.showPlaceholder option.value.type_}"
                    ''
        )
        (Prelude.List.indexed data.Option data.options)}
    parsePrinterOptsJSON ::
      Applicative f =>
      (forall a. PrinterOptsFieldType a => String -> f (Maybe a)) ->
      f (PrinterOpts Maybe)
    parsePrinterOptsJSON f =
      pure PrinterOpts
    ${Prelude.Text.concatMap
        { index : Natural, value : data.Option }
        ( \(option : { index : Natural, value : data.Option }) ->
            let lead = if Prelude.Natural.isZero option.index then "{" else ","

            in  ''
                    <*> f "${option.value.name}"
                ''
        )
        (Prelude.List.indexed data.Option data.options)}
    {---------- PrinterOpts field types ----------}

    class Aeson.FromJSON a => PrinterOptsFieldType a where
      parsePrinterOptType :: String -> Either String a

    instance PrinterOptsFieldType Int where
      parsePrinterOptType = readEither

    instance PrinterOptsFieldType Bool where
      parsePrinterOptType s =
        case s of
          "false" -> Right False
          "true" -> Right True
          _ ->
            Left . unlines $
              [ "unknown value: " <> show s,
                "Valid values are: \"false\" or \"true\""
              ]


    ${Prelude.Text.concatMapSep
        "\n"
        data.FieldType
        ( \(fieldType : data.FieldType) ->
            ''
            data ${data.typeName fieldType}
            ${Prelude.Text.concatMap
                { index : Natural, value : Text }
                ( \(enum : { index : Natural, value : Text }) ->
                    let lead =
                          if Prelude.Natural.isZero enum.index then "=" else "|"

                    in  ''
                          ${lead} ${enum.value}
                        ''
                )
                ( Prelude.List.indexed
                    Text
                    ( merge
                        { Enum =
                            \(x : data.EnumType) ->
                              Prelude.List.map
                                data.Enum
                                Text
                                data.showEnum
                                x.constructors
                        , ADT = \(x : data.ADT) -> x.constructors
                        }
                        fieldType
                    )
                )}  ${merge
                        { Enum =
                            \(x : data.EnumType) ->
                              "deriving (Eq, Show, Enum, Bounded)"
                        , ADT = \(x : data.ADT) -> "deriving (Eq, Show)"
                        }
                        fieldType}
            ''
        )
        data.fieldTypes}
    ${Prelude.Text.concatMapSep
        "\n"
        data.FieldType
        ( \(fieldType : data.FieldType) ->
            ''
            ${merge
                { Enum =
                    \(x : data.EnumType) ->
                      ''
                      instance Aeson.FromJSON ${data.typeName fieldType} where
                        parseJSON =
                          Aeson.withText "${data.typeName fieldType}" $ \s ->
                            either Aeson.parseFail pure $
                              parsePrinterOptType (Text.unpack s)''
                , ADT =
                    \(x : data.ADT) ->
                          "instance Aeson.FromJSON ${data.typeName
                                                       fieldType} where"
                      ++  ''

                          ${"  "}parseJSON = ${x.parseJSON}''
                }
                fieldType}

            instance PrinterOptsFieldType ${data.typeName fieldType} where
            ${merge
                { Enum =
                    \(x : data.EnumType) ->
                      ''
                        parsePrinterOptType s =
                          case s of
                      ${Prelude.Text.concatMap
                          data.Enum
                          ( \(enum : data.Enum) ->
                              ''
                                    "${data.showEnumPretty
                                         enum}" -> Right ${data.showEnum enum}
                              ''
                          )
                          x.constructors}      _ ->
                              Left . unlines $
                                [ "unknown value: " <> show s
                                , "Valid values are: ${list x}"
                                ]''
                , ADT =
                    \(x : data.ADT) ->
                      "  parsePrinterOptType = ${x.parsePrinterOptType}"
                }
                fieldType}
            ''
        )
        data.fieldTypes}''
